#include "geo_generator.h"
#include <numeric>
#include <algorithm>
#include <iomanip>
namespace BridgeWind
{
	std::vector<int> proportionalSplit(int x, const std::vector<double>& ratios);

	const Point& getStartPointByNext(
		const Point& startPoint,
		const Point& endPoint,
		const Point& nextStart,
		const Point& nextEnd
	);
	const Point& getStartPointByPrevious(
		const Point& startPoint,
		const Point& endPoint,
		const Point& previousStart,
		const Point& previousEnd
	);
	GeoGenerator::~GeoGenerator() {
		finalize();
	}
	GeoGenerator::GeoGenerator(const TopologyAnalyzer& a, const std::string& f, const SimulationParameters& p)
		: analyzer(a), filename(f), ofs(f), writtedWallPoints(), writtedFarfieldPoints(), params(p)
	{
		if (params.fieldSizeDefineMethod == fieldSizeDefineMethod::Default) {
			fieldDiameter = std::max(
				analyzer.getSourceGeometry()->getBoundingBoxWidth(),
				analyzer.getSourceGeometry()->getBoundingBoxHeight()
			) * 50.0;
		}
		else if (params.fieldSizeDefineMethod == fieldSizeDefineMethod::UserDefined) {
			fieldDiameter = params.userDefinedFieldDiameter;
		}
		else if (params.fieldSizeDefineMethod == fieldSizeDefineMethod::DiameterToMaxSizeRatio) {
			fieldDiameter = std::max(
				analyzer.getSourceGeometry()->getBoundingBoxWidth(),
				analyzer.getSourceGeometry()->getBoundingBoxHeight()
			) * params.filedToSizeRatio;
		}
		else {
			throw std::runtime_error("Invalid field size define method.");
		}
		
		if (!ofs.is_open()) {
			throw std::runtime_error("Failed to open file: " + filename);
		}
		ofs << std::setprecision(20);
	};
	void GeoGenerator::generateGeoFile() {
		const std::vector<std::unique_ptr<Loop>>& loops = analyzer.getLoops();
		if (loops.empty()) {
			throw std::runtime_error("No loops found in the topology analysis.");
		}
		if (loops.size() > 1) {
			// 多环情况
			generateGeoFileMultiLoop();
		}
		else if (loops.size() == 1) {
			// 单环
			generateGeoFileSingleLoop();
		}
		
	}
	void GeoGenerator::finalize() {
		if (ofs.is_open()) {
			ofs.close();
		}
		if (!ofs) {
			throw std::runtime_error("Failed to close file: " + filename);
		}
		std::cout << "Geo file generated successfully at: " << filename << std::endl;
	}
	void GeoGenerator::generateGeoFileSingleLoop()  {
		// 第一步：设置Geo文件的变量
		// 求每条线段的分段数
		const Loop& loop = *analyzer.getLoops()[0];//
		double loopLength = loop.getLengthAbstract();
		int segmentCount = loop.segmentCount();
		const std::vector<const GraphEdge*>& edges = loop.getEdges();
		

		std::cout << "Generating Geo file for single loop..." << std::endl;
		std::cout << "Loop length: " << loopLength << std::endl;
		geoWriteLineComment("Geo file generated by BridgeWind GeoGenerator");
		const std::vector<double>& lengthRatios = loop.getLengthRatiosAbstract();

		std::vector<int> MeshNumbers = proportionalSplit(params.circumferentialMeshNumber, lengthRatios);
		

		int varIndex = 1;

		for (const auto num : MeshNumbers) {
			std::string variableName = "N" + std::to_string(varIndex);
			geoSetVariable(variableName, num + 1);
			meshNumbersVariabls.emplace_back(variableName, num + 1);
			varIndex++;
		}
		geoSetVariable(BW_GEO_RADIUS_MESH_NUM_VAR_NAME, params.radialMeshNumber + 1);
		geoSetVariable(BW_GEO_CIRCUM_GROWTH_RATE_VAR_NAME, 1.0);
		geoSetVariable(BW_GEO_DEFAULT_RADIUS_GROWTH_RATE_VAR_NAME, params.radialMeshGrowthRate);
		
		// 第二步：写入点的坐标---------------------------------
		geoWriteLineComment("Setting points");

		int pointIndex = 1;

		this->wallPointStartIndex = pointIndex;
		geoWriteWallPoints(loop, pointIndex);

		this->farfieldPointStartIndex = pointIndex; // 记录墙面点的数量
		geoWriteFarfieldPoints(loop, pointIndex);

		this->centerPointIndex = pointIndex;
		geoSetPoint(centerPointIndex, Point(0.0, 0.0));
		pointIndex++;

		// 第三步：写入线的连接---------------------------------
		geoWriteLineComment("Setting Lines");
		int lineIndex = 1;

		geoWriteWallLine(loop, lineIndex);

		geoWriteConnectLine(loop, lineIndex);

		geoWriteFarfieldLine(loop, lineIndex);

		// 第四步： 写入面---------------------------------------
		geoWriteLineComment("Setting Surfaces");
		int surfaceIndex = 1;

		geoWriteSurfaces(loop, surfaceIndex);

		geoTransfiniteSurfaces(1, segmentCount);

		geoRecombineSurfaces(1, segmentCount);

		// 第五步： 写入物理组------------------------------

		geoSetPhysicalCurves("Solid Surface", 1, 1, segmentCount);
		geoSetPhysicalCurves("Farfield", 2, 2 * segmentCount + 1, 3 * segmentCount);
		geoSetPhysicalSurfaces("Fluid", 3, 1, segmentCount);



		
	}
	void GeoGenerator::generateGeoFileMultiLoop()  {

	}
	void GeoGenerator::geoSetVariable(std::string name, double value) {
		ofs << name << " = " << value << ";\n";
	}
	void GeoGenerator::geoSetVariable(std::string name, int value) {
		ofs << name << " = " << value << ";\n";
	}
	void GeoGenerator::geoSetPoint(int index, double x, double y, double z) {
		ofs << "Point(" << index << ") = {" << x << ", " << y << ", " << z << "};\n";
	}
	void GeoGenerator::geoSetPoint(int index, const Point& point) {
		ofs << "Point(" << index << ") = {" << point.x << ", " << point.y << ", " << 0.0 << "};\n";
	}
	void GeoGenerator::geoSetLine(int index, int startPointIndex, int endPointIndex) {
		ofs << "Line(" << index << ") = {" << startPointIndex << ", " << endPointIndex << "};\n";
	}
	void GeoGenerator::geoSetLine(
		int index,
		int startPointIndex,
		int endPointIndex,
		std::string meshPointCountVariable,
		std::string growthRateVariable
	) {
		ofs << "Line(" << index << ") = {" << startPointIndex << ", " << endPointIndex << "};";
		ofs << " Transfinite Curve {" << index << "} = " << meshPointCountVariable;
		ofs << " Using Progression " << growthRateVariable << ";\n";

	}
	void GeoGenerator::geoSetArc(
		int index,
		int startPointIndex,
		int centerPointIndex,
		int endPointIndex,
		std::string meshPointCountVariable,
		std::string growthRateVariable
	) {
		ofs << "Circle(" << index << ") = {" << startPointIndex << ", " << centerPointIndex << ", " << endPointIndex << "};";
		ofs << " Transfinite Curve {" << index << "} = " << meshPointCountVariable;
		ofs << " Using Progression " << growthRateVariable << ";\n";
	}
	void GeoGenerator::geoWriteLineComment(const std::string& comment) {
		ofs << "// " << comment << "\n";
	}
	void GeoGenerator::geoWriteSurface(int surfaceIndex, std::vector<int> nodes) {
		ofs << "Curve Loop(" << surfaceIndex << ") = {";
		for (int i = 0; i < nodes.size(); i++) {
			ofs << nodes[i];
			if (i != nodes.size() - 1) {
				ofs << ", ";
			}
		}
		ofs << "};";
		ofs << "Plane Surface(" << surfaceIndex << ") = {" << surfaceIndex << "};\n";
	}
	void GeoGenerator::geoTransfiniteSurface(int n){
		ofs << "Transfinite Surface {" << n <<"};\n";
	}
	void GeoGenerator::geoRecombineSurface(int n){
		ofs << "Recombine Surface {" << n << "};\n";
	}
	void GeoGenerator::geoSetPhysicalCurve(std::string name, int index, std::vector<int> indexes) {
		ofs << "Physical Curve(\"" << name << "\", " << index << ") = {";
		for (int i = 0; i < indexes.size(); i++) {
			ofs << indexes[i];
			if (i != indexes.size() - 1) {
				ofs << ", ";
			}
		}
		ofs << "};\n";
	}
	void GeoGenerator::geoSetPhysicalSurface(std::string name, int index, std::vector<int> indexes) {
		ofs << "Physical Surface(\"" << name << "\", " << index << ") = {";
		for (int i = 0; i < indexes.size(); i++) {
			ofs << indexes[i];
			if (i != indexes.size() - 1) {
				ofs << ", ";
			}
		}
		ofs << "};\n";
	}

	void GeoGenerator::geoWriteWallPoints(
		const Loop& loop, // 直接传入 Loop 对象
		int& pointIndex
	) {
		geoWriteLineComment("Setting Wall Points");
		const auto& nodes = loop.getNodes(); // 获取有序节点

		// 遍历每一个节点，它就是环上的一个顶点
		for (size_t i = 0; i < nodes.size(); ++i) {
			// 获取当前顶点
			const Point& current_point = nodes[i]->point;

			// 写入.geo文件
			geoSetPoint(pointIndex, current_point);

			// 记录这个点已经被写入
			writtedWallPoints.push_back(current_point);

			pointIndex++;
		}
		this->wallArcCenterStartIndex = pointIndex;
		// 对于圆弧，还需要写入它们的圆心作为额外的点
		const auto& edges = loop.getEdges();
		for (const auto& edge : edges) {
			if (edge->type == GraphEdge::GeomType::ARC) {
				const Point& center_point = edge->geometry.arc_ptr->center;
				geoSetPoint(pointIndex, center_point);
				// 这里也可以记录圆心点，如果需要的话
				pointIndex++;
			}
		}
	}
	void GeoGenerator::geoWriteFarfieldPoints(const Loop& loop, int& pointIndex) {
		// 确定圆周上第一个点的坐标
		geoWriteLineComment("Setting Farfield Points");
		const auto& nodes = loop.getNodes();
		Line ray(Point(0, 0), nodes[0]->point);
		// 使用极坐标初始化第一个点
		double angle = ray.angle();
		Point firstPoint(Point(0, 0), fieldDiameter / 2.0, angle);
		geoSetPoint(pointIndex, firstPoint);
		pointIndex++;
		for (int i = 0; i < nodes.size() - 1; i++) {
			angle += loop.getLengthRatiosAbstract()[i] * 2 * PI;
			Point point(Point(0, 0), fieldDiameter / 2.0, angle);
			geoSetPoint(pointIndex, point);
			pointIndex++;
		}
		angle += loop.getLengthRatiosAbstract()[nodes.size() - 1] * 2 * PI;
		Point lastPoint(Point(0, 0), fieldDiameter / 2.0, angle);
		if (!firstPoint.isSame(lastPoint)) {
			throw std::runtime_error("Farfield lastPoint doesn't is not same with the firstPoint");
		}
		

	}

	void GeoGenerator::geoWriteWallLine(const Loop& loop, int& lineIndex) {
		const auto& edges = loop.getEdges();
		int i = 0;
		int arcIndex = 0;
		for (const auto& edge : edges) {
			if (edge->type == GraphEdge::GeomType::LINE) {

				geoSetLine(
					lineIndex,
					getWallPointStartIndex() + i,
					i == edges.size() - 1?
					getWallPointStartIndex():
					getWallPointStartIndex() + i + 1,
					meshNumbersVariabls[i].first,
					BW_GEO_CIRCUM_GROWTH_RATE_VAR_NAME
				);
				lineIndex++;

			}
			if (edge->type == GraphEdge::GeomType::ARC) {
				geoSetArc(
					lineIndex,
					getWallPointStartIndex() + i,
					getWallArcCenterStartIndex() + arcIndex,
					i == edges.size() - 1 ?
					getWallPointStartIndex() :
					getWallPointStartIndex() + i + 1,
					meshNumbersVariabls[i].first,
					BW_GEO_CIRCUM_GROWTH_RATE_VAR_NAME
				);
				lineIndex++;
				arcIndex++;
			}

			i++;
		}
	}
	void GeoGenerator::geoWriteConnectLine(const Loop& loop, int& lineIndex) {
		
		for (int i = 0; i < loop.getNodes().size(); i++) {
			int innerIndex = getWallPointStartIndex() + i;
			int outerIndex = getFarfieldPointStartIndex() + i;
			geoSetLine(
				lineIndex,
				outerIndex,
				innerIndex,
				BW_GEO_RADIUS_MESH_NUM_VAR_NAME,
				BW_GEO_DEFAULT_RADIUS_GROWTH_RATE_VAR_NAME
				);
			lineIndex++;
		}
	}
	void GeoGenerator::geoWriteFarfieldLine(const Loop& loop, int& lineIndex) {
		for (int i = 0; i < loop.getNodes().size(); i++) {
			int startIndex = getFarfieldPointStartIndex() + i;
			int endIndex = 
				i == loop.getNodes().size() - 1 ? 
				getFarfieldPointStartIndex()
				:
				startIndex + 1
				;
			geoSetArc(
				lineIndex,
				startIndex,
				getCenterPointIndex(),
				endIndex,
				meshNumbersVariabls[i].first,
				BW_GEO_CIRCUM_GROWTH_RATE_VAR_NAME
			);
			lineIndex++;
		}
	}
	void GeoGenerator::geoWriteSurfaces(const Loop& loop, int& surfaceIndex) {
		const int nodeNum = loop.getNodes().size();
		for (int i = 1; i <= nodeNum; i++) {
			int index1 = i;
			int index2 = i == nodeNum ? nodeNum + 1 : nodeNum + i + 1;
			int index3 = 2 * nodeNum + i;
			int index4 =  nodeNum + i;
			//顺时针
			//geoWriteSurface(
			//	i,
			//	std::vector<int>{
			//		index1,
			//		-index2,
			//		-index3,
			//		index4
			//	}
			//);
			//逆时针
			geoWriteSurface(
				i,
				std::vector<int>{
					-index4,
					index3,
					index2,
					-index1
			}
			);

		}
	}
	void GeoGenerator::geoTransfiniteSurfaces(int startIndex, int endIndex) {
		for (int i = startIndex; i <= endIndex; i++) {
			geoTransfiniteSurface(i);
		}
	}
	void GeoGenerator::geoRecombineSurfaces(int startIndex, int endIndex) {
		for (int i = startIndex; i <= endIndex; i++) {
			geoRecombineSurface(i);
		}
	}

	void GeoGenerator::geoSetPhysicalCurves(
		std::string name, 
		int surfaceIndex, 
		int startIndex, 
		int endIndex
	) {
		std::vector<int> vec(endIndex - startIndex + 1);
		std::iota(vec.begin(), vec.end(), startIndex);
		geoSetPhysicalCurve(name, surfaceIndex, vec);
	}
	void GeoGenerator::geoSetPhysicalSurfaces(
			std::string name,
			int surfaceIndex,
			int startIndex,
			int endIndex
			) {
		std::vector<int> vec(endIndex - startIndex + 1);
		std::iota(vec.begin(), vec.end(), startIndex);
		geoSetPhysicalSurface(name, surfaceIndex, vec);
	}
	std::vector<int> proportionalSplit(int x, const std::vector<double>& ratios) {
		int n = ratios.size();
		std::vector<double> raw_parts(n);
		std::vector<int> int_parts(n);

		// 计算总比例
		double sum_ratios = std::accumulate(ratios.begin(), ratios.end(), 0.0);

		// 初步分配（浮点数 -> 向下取整）
		for (int i = 0; i < n; ++i) {
			raw_parts[i] = x * ratios[i] / sum_ratios;
			int_parts[i] = static_cast<int>(std::floor(raw_parts[i]));
		}

		// 计算误差差值
		int remainder = x - std::accumulate(int_parts.begin(), int_parts.end(), 0);

		// 记录每个项的误差（浮点值 - 向下取整）
		std::vector<std::pair<int, double>> deltas(n);
		for (int i = 0; i < n; ++i) {
			deltas[i] = { i, raw_parts[i] - int_parts[i] };
		}

		// 按照误差从大到小排序
		std::sort(deltas.begin(), deltas.end(),
			[](const std::pair<int, double>& a, const std::pair<int, double>& b) {
				return a.second > b.second;
			});

		// 进行误差补偿，加回缺失的 remainder
		for (int i = 0; i < remainder; ++i) {
			int_parts[deltas[i].first] += 1;
		}

		return int_parts;
	}
	const Point& getStartPointByNext(
		const Point& startPoint,
		const Point& endPoint,
		const Point& nextStart,
		const Point& nextEnd
	) {
		if (
			startPoint.isSame(nextStart) ||
			startPoint.isSame(nextEnd)
			) {
			return endPoint;
		}
		else if (
			endPoint.isSame(nextStart) ||
			endPoint.isSame(nextEnd)
			) {
			return startPoint;
		}
		else {
			throw std::runtime_error("Points don't match each other in getStartPointByNext.");
		}
	}
	const Point& getStartPointByPrevious(
		const Point& startPoint,
		const Point& endPoint,
		const Point& previousStart,
		const Point& previousEnd
	) {
		if (
			startPoint.isSame(previousStart) ||
			startPoint.isSame(previousEnd)
			) {
			return startPoint;
		}
		else if (
			endPoint.isSame(previousStart) ||
			endPoint.isSame(previousEnd)
			) {
			return endPoint;
		}
		else {
			throw std::runtime_error("Points don't match each other in getStartPointByNext.");
		}
	}

	//void GeoGenerator::geoWriteMeshVariables(
	//	double loopLength,
	//	const std::vector<const GraphEdge*>& edges

	//) {
	//	
	//	
	//	
	//}
	//void GeoGenerator::geoWriteStartPointByNext(
	//	int& pointIndex,
	//	const Line* line,
	//	const Line* nextLine
	//) {
	//	const Point& startPoint = line->begin;
	//	const Point& endPoint = line->end;
	//	const Point& nextStart = nextLine->begin;
	//	const Point& nextEnd = nextLine->end;

	//	const Point& point = getStartPointByNext(
	//		startPoint,
	//		endPoint,
	//		nextStart,
	//		nextEnd
	//	);
	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);
	//	
	//}
	//void GeoGenerator::geoWriteStartPointByNext(
	//	int& pointIndex,
	//	const Line* line,
	//	const Arc* nextArc
	//) {
	//	const Point& startPoint = line->begin;
	//	const Point& endPoint = line->end;
	//	const Point& nextStart = nextArc->getStartPoint();
	//	const Point& nextEnd = nextArc->getEndPoint();

	//	const Point& point = getStartPointByNext(
	//		startPoint,
	//		endPoint,
	//		nextStart,
	//		nextEnd
	//	);
	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);
	//}
	//void GeoGenerator::geoWriteStartPointByNext(
	//	int& pointIndex,
	//	const Arc* arc,
	//	const Arc* nextArc
	//) {
	//	const Point& startPoint = arc->getStartPoint();
	//	const Point& endPoint = arc->getEndPoint();
	//	
	//	const Point& nextStart = nextArc->getStartPoint();
	//	const Point& nextEnd = nextArc->getEndPoint();

	//	const Point& point = getStartPointByNext(
	//		startPoint,
	//		endPoint,
	//		nextStart,
	//		nextEnd
	//	);
	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);

	//	const Point& centerPoint = arc->getCenterPoint();
	//	geoSetPoint(pointIndex, centerPoint);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(centerPoint);

	//}
	//void GeoGenerator::geoWriteStartPointByNext(
	//	int& pointIndex,
	//	const Arc* arc,
	//	const Line* nextLine
	//) {
	//	const Point& startPoint = arc->getStartPoint();
	//	const Point& endPoint = arc->getEndPoint();
	//	const Point& nextStart = nextLine->begin;
	//	const Point& nextEnd = nextLine->end;

	//	const Point& point = getStartPointByNext(
	//		startPoint,
	//		endPoint,
	//		nextStart,
	//		nextEnd
	//	);
	//	

	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);

	//	const Point& centerPoint = arc->getCenterPoint();
	//	geoSetPoint(pointIndex, centerPoint);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(centerPoint);
	//}
	//void GeoGenerator::geoWriteStartPointByPrevious(
	//	int& pointIndex,
	//	const Line* line,
	//	const Line* previousLine
	//) {
	//	const Point& startPoint = line->begin;
	//	const Point& endPoint = line->end;
	//	const Point& previousStart = previousLine->begin;
	//	const Point& previousEnd = previousLine->end;

	//	const Point& point = getStartPointByPrevious(
	//		startPoint,
	//		endPoint,
	//		previousStart,
	//		previousStart
	//	);
	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);
	//}
	//void GeoGenerator::geoWriteStartPointByPrevious(
	//	int& pointIndex,
	//	const Line* line,
	//	const Arc* previousArc
	//) {
	//	const Point& startPoint = line->begin;
	//	const Point& endPoint = line->end;
	//	const Point& previousStart = previousArc->getStartPoint();
	//	const Point& previousEnd = previousArc->getEndPoint();

	//	const Point& point = getStartPointByPrevious(
	//		startPoint,
	//		endPoint,
	//		previousStart,
	//		previousStart
	//	);
	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);

	//}
	//void GeoGenerator::geoWriteStartPointByPrevious(
	//	int& pointIndex,
	//	const Arc* arc,
	//	const Arc* previousArc
	//) {
	//	const Point& startPoint = arc->getStartPoint();
	//	const Point& endPoint = arc->getEndPoint();
	//	const Point& previousStart = previousArc->getStartPoint();
	//	const Point& previousEnd = previousArc->getEndPoint();

	//	const Point& point = getStartPointByPrevious(
	//		startPoint,
	//		endPoint,
	//		previousStart,
	//		previousStart
	//	);
	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);

	//	const Point& centerPoint = arc->getCenterPoint();
	//	geoSetPoint(pointIndex, centerPoint);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(centerPoint);
	//}
	//void GeoGenerator::geoWriteStartPointByPrevious(
	//	int& pointIndex,
	//	const Arc* arc,
	//	const Line* previousArc
	//) {
	//	const Point& startPoint = arc->getStartPoint();
	//	const Point& endPoint = arc->getEndPoint();
	//	const Point& previousStart = previousArc->begin;
	//	const Point& previousEnd = previousArc->end;

	//	const Point& point = getStartPointByPrevious(
	//		startPoint,
	//		endPoint,
	//		previousStart,
	//		previousStart
	//	);
	//	geoSetPoint(pointIndex, point);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(point);

	//	const Point& centerPoint = arc->getCenterPoint();
	//	geoSetPoint(pointIndex, centerPoint);
	//	pointIndex++;
	//	writtedFarfieldPoints.push_back(centerPoint);
	//}


	//void GeoGenerator::geoWriteWallPoints(
	//	const std::vector<const GraphEdge*>&  edges, 
	//	int& pointIndex
	//) {

	//	
	//	for (size_t i = 0; i < edges.size() - 1; i++) {
	//		if (
	//			edges[i]->type == GraphEdge::GeomType::LINE
	//			&&
	//			edges[i + 1]->type == GraphEdge::GeomType::LINE
	//			) {
	//			const Line* line = edges[i]->geometry.line_ptr;
	//			const Line* nextLine = edges[i + 1]->geometry.line_ptr;
	//			geoWriteStartPointByNext(
	//				pointIndex,
	//				line,
	//				nextLine
	//			);
	//		}
	//		else if (
	//			edges[i]->type == GraphEdge::GeomType::LINE
	//			&&
	//			edges[i + 1]->type == GraphEdge::GeomType::ARC
	//			) {
	//			const Line* line = edges[i]->geometry.line_ptr;
	//			const Arc* nextArc= edges[i + 1]->geometry.arc_ptr;
	//			geoWriteStartPointByNext(
	//				pointIndex,
	//				line,
	//				nextArc
	//			);
	//		}
	//		else if (
	//			edges[i]->type == GraphEdge::GeomType::ARC
	//			&&
	//			edges[i + 1]->type == GraphEdge::GeomType::LINE
	//			) {
	//			const Arc* arc = edges[i]->geometry.arc_ptr;
	//			const Line* nextLine = edges[i + 1]->geometry.line_ptr;
	//			geoWriteStartPointByNext(
	//				pointIndex,
	//				arc,
	//				nextLine
	//			);
	//		}
	//		else if (
	//			edges[i]->type == GraphEdge::GeomType::ARC
	//			&&
	//			edges[i + 1]->type == GraphEdge::GeomType::ARC
	//			) {
	//			const Arc* arc = edges[i]->geometry.arc_ptr;
	//			const Arc* nextArc = edges[i + 1]->geometry.arc_ptr;
	//			geoWriteStartPointByNext(
	//				pointIndex,
	//				arc,
	//				nextArc
	//			);
	//		}

	//		else {
	//			throw std::runtime_error("Unknown edge type in GeoGenerator::geoWriteWallPoints");
	//		}
	//	}




	//	if (
	//		edges.back()->type == GraphEdge::GeomType::LINE
	//		&&
	//		edges[edges.size() - 2]->type == GraphEdge::GeomType::LINE
	//		) {
	//		const Line* line = edges.back()->geometry.line_ptr;
	//		const Line* previousLine = edges[edges.size() - 2]->geometry.line_ptr;
	//		geoWriteStartPointByPrevious(
	//			pointIndex,
	//			line,
	//			previousLine
	//		);
	//	}
	//	else if (
	//		edges.back()->type == GraphEdge::GeomType::LINE
	//		&&
	//		edges[edges.size() - 2]->type == GraphEdge::GeomType::ARC
	//		) {
	//		const Line* line = edges.back()->geometry.line_ptr;
	//		const Arc* previousArc = edges[edges.size() - 2]->geometry.arc_ptr;
	//		geoWriteStartPointByPrevious(
	//			pointIndex,
	//			line,
	//			previousArc
	//		);
	//	}
	//	else if (
	//		edges.back()->type == GraphEdge::GeomType::ARC
	//		&&
	//		edges[edges.size() - 2]->type == GraphEdge::GeomType::LINE
	//		) {
	//		const Arc* arc = edges.back()->geometry.arc_ptr;
	//		const Line* previousLine = edges[edges.size() - 2]->geometry.line_ptr;
	//		geoWriteStartPointByPrevious(
	//			pointIndex,
	//			arc,
	//			previousLine
	//		);
	//	}
	//	else if (
	//		edges.back()->type == GraphEdge::GeomType::ARC
	//		&&
	//		edges[edges.size() - 2]->type == GraphEdge::GeomType::ARC
	//		) {
	//		const Arc* arc = edges.back()->geometry.arc_ptr;
	//		const Arc* previousArc = edges[edges.size() - 2]->geometry.arc_ptr;
	//		geoWriteStartPointByPrevious(
	//			pointIndex,
	//			arc,
	//			previousArc
	//		);
	//	}
	//	else {
	//		throw std::runtime_error("Unknown edge type in GeoGenerator::geoWriteWallPoints");
	//	}





	//	
	//}
	
}